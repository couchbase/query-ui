/*
Copyright 2021-Present Couchbase, Inc.

Use of this software is governed by the Business Source License included in
the file licenses/BSL-Couchbase.txt.  As of the Change Date specified in that
file, in accordance with the Business Source License, use of this software will
be governed by the Apache License, Version 2.0, included in the file
licenses/APL2.txt.
*/

/*
 * This is a listener for the N1QL parser generated by analyzing the goyacc N1QL parser.
 */

import antlr4 from './n1qlParser/antlr4.js';
import n1qlLexer from './n1qlParser/n1qlLexer.js';
import n1qlParser from './n1qlParser/n1qlParser.js';
import n1qlListener from './n1qlParser/n1qlListener.js';
//import * as fs from 'fs';

const { CommonTokenStream, InputStream } = antlr4;

let debug = false;

function ctxToString(ctx) {
  let result = "";
  result += "cc: " + ctx.getChildCount();
  result += ", text: " + ctx.getText();
  if (ctx.className)
    result += ", name: " + ctx.className().getText();
  if (ctx.LBRACKET)
    result += ", lbracket: " + ctx.LBRACKET();

  if (ctx.getChildCount() > 0) {
    result += '\n\t';
    ctx.children.forEach(child => {
        result += child.getText();
        if (child.symbol)
          result += " (" + child.symbol.type + ")";
        result += ", ";
      }
    );
  }


  return result;
}

// convenience function to determine if a child is a certain kind of token
function childIs(child,tokenNum) {
  return(child.symbol && child.symbol.type == tokenNum);
}

class myN1qlListener extends n1qlListener {

  constructor(currentParseResult) {
    super();
    this.currentParseResult = currentParseResult;
  }

  // Enter a parse tree produced by n1qlParser#input.
  enterInput(ctx) {
  }

  // Exit a parse tree produced by n1qlParser#input.
  exitInput(ctx) {
  }

  // Exit a parse tree produced by n1qlParser#stmt_body.
  exitStmt_body(ctx) {
    if (ctx.getChildCount() > 0)
      this.currentParseResult.stmt_category = ctx.children[0].ruleIndex;
  }

  // Exit a parse tree produced by n1qlParser#select_stmt.
  exitSelect_stmt(ctx) {
    this.currentParseResult.stmt = n1qlParser.RULE_select_stmt;
  }

  // Exit a parse tree produced by n1qlParser#dml_stmt.
  exitDml_stmt(ctx) {
    if (ctx.getChildCount() > 0)
      this.currentParseResult.stmt = ctx.children[0].ruleIndex;
  }

  // Exit a parse tree produced by n1qlParser#ddl_stmt.
  exitDdl_stmt(ctx) {
    if (ctx.getChildCount() > 0)
      this.currentParseResult.stmt = ctx.children[0].ruleIndex;
  }

  // keep track of functions used
  exitFunction_name(ctx) {
    this.functions_used.push(ctx.IDENT());
  }

  // Exit a parse tree produced by n1qlParser#use_keys.
  exitUse_keys(ctx) {
    this.currentParseResult.use_keys = true;
  }

  // Exit a parse tree produced by n1qlParser#opt_where.
  exitOpt_where(ctx) {
    this.currentParseResult.has_where = (ctx.getChildCount() > 0);
  }

  // Exit a parse tree produced by n1qlParser#where.
  exitWhere(ctx) {
    if (ctx.getChildCount() >= 2)
      this.currentParseResult.where = ctx.children[1].getText();
  }

  // Exit a parse tree produced by n1qlParser#expr.
  exitExpr(ctx) {
    let expr = ctx.expr();
    let c_expr = ctx.c_expr();
    let DOT = ctx.DOT();
    let IDENT = ctx.IDENT();
    let LBRACKET = ctx.LBRACKET();

    if (DOT && IDENT)
      this.currentParseResult.path_expr.push(IDENT.getText());
    if (LBRACKET)
      this.currentParseResult.path_expr.push('[]');
  }

  // Exit a parse tree produced by n1qlParser#c_expr.
  exitC_expr(ctx) {
    var IDENT = ctx.IDENT();
    var IDENT_ICASE = ctx.IDENT_ICASE();
    var SELF = ctx.SELF();
    // whenever we see an IDENT, it is a field name used in an expression
    if (IDENT || IDENT_ICASE) {
      this.currentParseResult.newPath(ctx.getText());
    }
  }
}

class MyParseCancellationException extends Error{
  constructor(line,column,message) {
    super()
    this.line = line;
    this.column = column;
    this.message = message;
    //Error.captureStackTrace(this, MyParseCancellationException);
  }
}

class myErrorListener extends antlr4.error.ErrorListener {
  constructor() {
    super();
  }

  syntaxError(recognizer, symbol, line, column, message, payload) {
    console.log("\n\n\nGot error: " + symbol + "," + line + "," + column + "," + message + "," + payload);
    throw new MyParseCancellationException(line,column,message);
  }
}

class myParseResult {
  constructor() {
    this.path_expr = [];
    this.all_paths_used = [];
    this.functions_used = [];
    this.stmt_category = 0; // explain, prepare, advise, execute, or regular stmtm
    this.stmt = 0; // top level statement: select, update, delete, merge, upsert
  }

  newPath(pathElement) {
    if (this.path_expr.length > 0)
      this.all_paths_used.push(this.path_expr);

    this.path_expr = [pathElement];
  }

  finish() {
    // output any outstanding path expressions
    if (this.path_expr.length > 0) {
      this.all_paths_used.push(this.path_expr);
      this.path_expr = [];
    }

    switch (this.stmt_category) {
      case n1qlParser.RULE_stmt: this.isStatement = true; break;
      case n1qlParser.RULE_advise: this.isAdvise = true; break;
      case n1qlParser.RULE_explain: this.isExplain = true; break;
      case n1qlParser.RULE_prepare: this.isPrepare = true; break;
      case n1qlParser.RULE_execute: this.isExecute = true; break;
    }

    switch (this.stmt) {
      case n1qlParser.RULE_select_stmt: this.isSelect = true; break;
      case n1qlParser.RULE_insert: this.isInsert = true; break;
      case n1qlParser.RULE_update: this.isUpdate = true; break;
      case n1qlParser.RULE_upsert: this.isUpsert = true; break;
      case n1qlParser.RULE_delete_: this.isDelete = true; break;
      case n1qlParser.RULE_merge: this.isMerge = true; break;
      case n1qlParser.RULE_index_stmt: this.isIndex = true; break;
      case n1qlParser.RULE_scope_stmt: this.isScope = true; break;
      case n1qlParser.RULE_collection_stmt: this.isCollection = true; break;

    }

  }
}


//
// Parse a string containing one or more N1QL queries (separated by semicolons)
//
// returns an array of results, which are either a myParseResult or a parse error
//

function parse(n1ql) {
  var currentParseResults = [];
  var chars = new antlr4.InputStream(n1ql);
  var lexer = new n1qlLexer(chars);
  var tokens = new CommonTokenStream(lexer);
  var parser = new n1qlParser(tokens);
  var errorListener = new myErrorListener();
  lexer.removeErrorListeners();
  parser.removeErrorListeners();
  lexer.addErrorListener(errorListener);
  parser.addErrorListener(errorListener);

  try {
    // loop over the text until we hit EOF, getting a result for as many queries as exist there
    while (!tokens.fetchedEOF) {
      var currentParseResult = new myParseResult();
      var tree = parser.input();
      var listener = new myN1qlListener(currentParseResult);
      antlr4.tree.ParseTreeWalker.DEFAULT.walk(listener, tree);
      currentParseResult.finish();
      currentParseResults.push(currentParseResult);
    }
  } catch (error) {
    // console.log("Error line: " + error.line + ", column: " + error.column + ": " + error.message);
    // let line = n1ql.split('\n')[error.line-1];
    // console.log(line.substring(0,error.column) + '^^^' + line.substring(error.column));
    currentParseResults.push(error);
  }

  return(currentParseResults);
}

var N1qlParser = {
  parse: parse,
};

export default N1qlParser;
